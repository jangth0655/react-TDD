# ✅ 테스트 학습 시작 (2022.12.15 ~)

#### ❓ What is "Software Testing"

- 제품 or 서비스의 품질을 확인
- 소프트웨어의 버그 찾기
- **제품(함수, 기능, UI, 성능 API 스펙 등)이 예상하는 대로 동작하는지 확인**
- 목표, 플랫폼, 환경에 따라서 다양한 테스트가 존재한다.

#### ⏸️ 테스트 프로세스

1. 코드 작성
2. 테스트 코드 작성
   - 요구사항에 맞는지 확인하면서 작성
3. 주기적으로 실행하면서 성공 또는 실패하는지 확인 → 실패한다면 다시 성공하도록 코드 작성

#### 🗓️ When "Software Test" 언제 테스트를 작성해야할까?

- 개발하면서 동시에 수시로 테스트 작성 (자동화)
- 장점
  - 쉽게 작성 가능
  - 속도 빠르다
  - 높은 커버리지 (꼼꼼하게 테스트 작성하기 때문에)

#### 🎯 Why "Software Test"

테스트를 작성하면서 우리가 구현한 코드가 예상하는 대로 작동한다는 점에 큰 **자신감을 얻을 수 있다**.

- 기능이 정상 동작 확인
- 요구 사항 만족
- 이슈에 대해 예측
- 개발단계에서 실시간으로 버그를 빠르게 발견
- 자신감 있게 리팩토링할 수 있다.
- 유지보수성이 높다.
- 코드의 품질 향상
- 코드간 의존성을 낮춤 (독립적으로 모듈 작성)
- 좋은 문서화
- 시간을 절약할 수 있다.

#### ⛰️ 테스트 피라미드 (Test Pyramid)

<img height="200" src="https://blog.kakaocdn.net/dn/muQBS/btqCLcI3tQY/AvYdY1Ut3sY3kyyKrkjx1K/img.png" />

- 환경에 따라 다양한 테스트 종류가 있지만, 공통으로 작성해야 하는 것을 나타낸다.
- 유닛테스트 ~ E2E 테스트로 갈수록 비용과 노력이 증가 반면 테스트 실행 속도가 느리다.

1. **Unit Test (단위 테스트)**
   - 독립적인 하나의 함수, 모듈, 클래스, 컴포넌트를 테스트

<br />

2. **Integration Test (통합 테스트)**
   - 여러가지의 단위를 통합하였을 때 각 단위가 상호작용을 잘하는지, 잘 작동하는지 테스트

<br />

3. **E2E Test (end-to-end)**
   - UI테스트, 사용자 테스트
   - 최종적으로 사용자가 실제 사용했을 경우 플로우를 테스트

<br /><br />

---

#### TDD (Test-driven development : 테스트 주도 개발 방식)

- 개발(코드 작성)전 요구사항이 명확할 경우 테스트 코드를 먼저 작성
- 과정 (반복)

  1. 테스트 코드 작성
  2. 테스트 코드 실행 → 실패 (구현 전)
  3. 테스트 코드가 성공할 수 있도록 그만큼의 코드 작성
  4. 테스트 코드 모두 성공 → 리팩토링 진행

- 장점

  - 테스트를 먼저 작성하기 위해서 요구 사항 및 철저한 이해 및 점검
  - 사용자 입장에서 코드를 작성 (내부 구현사항 보다는 인터페이스 위주로 작성, 코드 퀄리티 향상)
  - 시스템 전번적인 설계 향상과 개발 집중력 향상

- TDD 방식은 개발자, 팀의 자유 하지만 메인 리파지토리에 머지, 리뷰하기 전에 꼭 테스트 코드를 포함해야한다.

---

### ✅ 좋은테스트 코드 작성하기 · 원칙

#### 🔒 테스트의 비밀

테스트하고자 하는 기능이나 코드가 변경된다면 테스트코드도 항상 업데이트 해야한다.

1. 한번 작성된 테스트 코드는 영원히 유지보수 해야한다. (클린코딩)
2. 내부 구현 사항을 테스트 ❌ → 사용자 입장에서 api만을 테스트한다.
3. 재사용성을 높이기(테스트 유틸리티)
4. 배포용 코드와 철저히 분리
5. 테스트코드를 통한 문서화

#

#### 좋은 테스트 구조

하나의 테스트 코드를 작성을 하면 테스트 수행 전후에따라 나뉜다.

- Before
  - beforeEach : 테스트 수행되기 전 호출
  - beforeAll : 테스트 수행되기 전 딱 한번만 호출
- After
  - AfterEach : 테스트 수행 이후 호출
  - AfterAll : 테스트 수행 이후 딱 한번만 호출

테스트 구조는 AAA

- 테스트를 위한 오브젝트를 생성하는 등 데이터를 **준비** (Arrange, Given) - **재사용**
- 테스트를 **실행** (Act, When) - **의도적으로 실패하기**(다른 값을 넣어 실패했을 때를 체크)
- 실행된 결과값을 예상하는 값과 **검증** (Assert, Then) **가장 마지막**

#### 좋은 테스트의 원칙 (FIRST)

Fast : 테스트 코드가 **빠르게 수행**될 수 있도록 만드는 것(**느린것에 대한 의존성 낮추기**)

- 파일, 데이터베이스, 네트워크에 대해 의존하여 테스트할 경우 (목, 스텁사용하여 낮추기)

Isolated : 고립적으로 독립적으로 만들어야한다.

- 최소한의 유닛으로 검증하기 (하나의 테스트에서 너무 많은 것을 테스트 ❌)

Repeatable : 반복이 가능하도록 만들어라 (외부 환경, 코드에 의존하는 경우)

- 실행할 때마다 동일한 결과를 유지해야한다.
- 동일한 테스트 코드임에도 불구하고 언제 실행하는지에 따라 다른 결과를 제공 ❌

Self-Validating

- 스스로 결과를 검증하기
- 자동화를 통한 검증단계

Timely

- 시기적절하게 테스트 코드 작성
- 사용자에게 베포되기 이전에 테스트 코드 작성

#### 테스트의 범위 (Right BICEP)

Right : 모든 요구 사항이 정상 동작하는지 확인, 모든 결과가 정확한지

B : Boundary conditions

- 모든 코너 케이스에 대해 테스트하기  
  (잘못된 포맷의 인풋, null, 특수문자, 잘못된 이메일, 작은 숫자, 큰 숫자, 중복, 순서 등)

I : Inverse relationship

- 역관계를 적용해서 결과값을 확인  
  (일관성 유지 5+5 =10, 그럼 반대로 10-5 or )

C : Cross-check

- 다른 수단을 이용해서 결과값이 맞는지 확인
  (여러가지 이용해서 결과값 확인)

E : Error conditions

- 불행한 경로에 대해 우아하게 처리 하는가?
  (네트워크 에러, 메모리부족, 데이터베이스 중지....)

P : Performance characteristics

- 성능 확인은 테스트를 통해 정확한 수치로 확인

#### 테스트 커버리지 CORRECT

C : Conformance

- 특정한 포멧을 준수하는지

O : Ordering

- 순서 조건확인 (순서가 중요한 경우)

R : Range

- 숫자의 범위 (제한된 범위보다 작거나 큰 경우)

R : Reference

- 외부 의존성 유무  
  (~일때, ~가 되어 있을때, 어떤 특정한 상황/상태일때, 가정하는 상황이 아닐 때)

E : Existence

- 값이 존재 하지 않을 때 어떻게 동작  
  (null, undefined, "", 0)

C : Cardinality

- 0,1,N 법칙에 따라 검증  
  (하나도 없을 때, 하나만 있을 때, 여러개가 있을 때)

T:Time

- 상대, 절대, 동시의 일들이 발생했을 경우  
  (소비한 시간, 지역(나라마다, 지역마다) 시간, 순서가 맞지 않는 경우)

---

### ✅ TDD

**Test-driven development, 개발(코드 작성)전 테스트 코드를 먼저 작성한다.**

사용자 입장에서 코드를 작성할 수 있다.
인터페이스 위주의 코드를 작성할 수 있다.
모든 요구 사항에 대해 점검할 수 있다.

- 실패한 테스트 작성 (반복)
- 테스트 성공할 정도 코드 작성 (반복)
- 기반으로 리팩토링 진행
